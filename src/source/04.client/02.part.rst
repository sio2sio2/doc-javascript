Particularidades
****************

.. _webpack-entry-point:

Punto de entrada
================
Hasta ahora hemos definido el punto de entrada de la manera más simple posible:

.. code-block:: js

   entry: "./src/js/index.js"

que equivale a:

.. code-block:: js

   entry: {
      main: "./src/js/index.js"
   }

Esta equivalencia es la que provoca que para :program:`webpack` ``[name]`` se
sustituya por *main*, por lo que:

.. code-block:: js

   output: {
      filename: "js/[name].bundle.js"
   }

provoca que el fichero de salida sea :file:`js/main.bundle.js` (dentro de
:file:`dist/`, por supuesto). Como ya se ha explicado, este fichero no contiene
únicamente el punto de entrada :file:`src/js/index.js`, sino que cualquier
script en javascript que se importe dentro de él y, a se vez, los importados por
los importados, pasarán a formar parte de este fichero resultante. Los ficheros
de otra naturaleza importados en el propio código *Javascript* o a través del
código |HTML| o |CSS| de la aplicación también se procesarán pero para ello será
necesario el uso de plugins y cargadores (como ya se ha practicado) y,
obviamente, el resultado acabará en otros ficheros distintos.

Por tanto, una primera variante es alternar ese nombre predeterminado para
que ``[name]`` cambie a otro valor más apropiado:

.. code-block:: js

   entry: {
      "leaflet.mipluginmolon": "./src/js/index.js"
   }

AHora bien, esto no acaba aquí. Si estamos desarrollando una aplicación que se
compone de dos páginas web distintas, las cuales usan sendos scripts, podemos
hacer:

.. code-block:: js

   entry: {
      "site": ["./src/js/page1.js", "./src/js/page2.js"]
   }

lo cual tendrá el efecto de embutir ambos *scripts*\ [#]_ en un único fichero
resultante. Esto es necesario porque al ser dos *scripts* independientes
utilizar el primero u el segundo como punto de entrada no incluiría al otro en
la salida. Otra variante es:

.. code-block:: js

   entry: {
      "page1": "./src/js.page1.js",
      "page2": "./src/js.page2.js",
   }

que mantendrá ambos *scripts* separados creando dos ficheros de salida.

.. warning:: Cuando el desarrollo no es una aplicación final, sino una librería,
   es sumamente importante tener en cuenta que las librerías son útiles porque
   ofrecen (o sea, exportan) algo al código que las invoca. Al tratar :ref:`la
   salida <webpack-output>` volveremos a este concepto. Es indispensable tener
   presente que, si un  punto de entrada encadena varios archivos, se exportará
   aquello que exporte el último fichero de la lista. Por eso, debe escribirse
   esto:

   .. code-block:: js

      entry: {
         main: ["./src/index.css", "./src/index.js"]
      }
      
   y no:

   .. code:: js

      entry: {
         main: ["./src/index.js", "./src/index.css"]
      }

   ya que en este segundo caso, se exportará lo que exporte un fichero |CSS|, o
   sea, nada.

Carga de módulos
================
Sistema de módulos
------------------
Como se verá en los :ref:`ejemplos posteriores <webpack-ejemplos>`, lo habitual
es que el código requiera cargar módulos propios o ajenos. :program:`webpack`
permite que se usa tanto el sistema CommonJS_ como el *ES2015*. Un buen criterio
es:

+ Usar CommonJS_ en el fichero de configuración de :program:`webpack`.
+ Usar *ES2015* dentro del código de la propia aplicación, ya que es el estándar
  aprobado y bajo determinadas circunstancias (como no importar aplicaciones de
  terceros\ [#]_ dentro del propio código), genera un código directamente usable
  en navegadores modernos.

.. _webpack-conf-import:

Importación desde la configuración
----------------------------------
Ya se ha visto que desde el propio código puede llevarse a cabo la importación:

.. code-block:: js

   import L from "leaflet";
   import "leaflet/dist/leaflet.css";  // El CSS de Leaflet
   import $ from "jquery";

Usando el estilo *ES2015*; también valdría CommonJS_. En principio, sea cual sea
la naturaleza de lo importado (código *Javascript*, |CSS|, una imagen, etc)
podemos usar este método. 

Alternativamente, las importaciones también puede hacerse desde el fichero de
configuración, aunque en este caso distinguiremos entre el código *Javascript* y
el resto.

* Para **código Javascript** puede usarse el plugin Provide_:

  .. code-block:: js

     // webpack.config.js
     const webpack = require("webpack");

     // ...

     module.exports = {
        // ...
        plugins: [
           new webpack.ProvidePlugin({
              L: "leaflet",
              $: "jquery"
           })
        ]
     }

  Para configurar el *plugin* hay que entender que las claves son identificadores
  y los valores cuál módulo se carga, de manera que cuando :program:`webpack`
  encuentre el identificador :code:`L` en el código procede a cargar el módulo
  *leaflet*\ [#]_. El identificador puede ser la propiedad de un objeto. Por
  ejemplo, esto es perfectamente válido:

  .. code-block:: js

     plugins: [
        new webpack.ProvidePlugin({
           L: "leaflet",
           "L.Control.Search": "leaflet-search",
           $: "jquery"
        })
     ]

  Entiéndase que lo exportado por el módulo cargado es el valor que
  adquirirá el identificar en el código. Ahora bien, si el módulo exporta de esta
  manera:

  .. code-block:: js

     export {a, b, c}

  y nuestra intención es definir el identificador *a*, podemos entonces hacer:

  .. code-block:: js

     a: [ "./mimodulo.js", "a" ]

* El **resto** de importaciones podemos llevarlas a cabo añadiéndolas al punto
  de entrada:

  .. code-block:: js

     entry: {
        "leaflet.mipluginmolon": [
            "./src/js/index.js",
            "leaflet/dist/leaflet.css"
        ]
     }

.. note:: El inconveniente de hacer las importaciones a través de la
   configuración radica en que si se usa nuestro desarrollo como componente
   para una tercera aplicación, las dependencias no se encuentran dentro
   del propio código y esto puede hacer un poco más complicado su uso.

Exclusión de dependecias
------------------------
Si nuestra intención es desarrollar una librería es bastante probable que
queramos desarrollar varias salidas y alguna de ellas no contenga las
dependencias.

.. seealso:: Véase el epígrafe dedicado a :ref:`múltiples salidas
   <webpack-multi>`.

Para excluir de la salida las dependencias, de nuevo, hay que hacer distinción
entre el código *Javascript* y el resto:

.. _webpack-externals:

* El **codigo Javascript** debe cargarse y excluirse, no simplemente dejar de
  cargarse. Se haya cargado en el código o en la configuración, el método de
  exclusión es el mismo: el atributo `externals
  <https://webpack.js.org/configuration/externals/>`_:

  .. code-block:: js

     const config = {
        // ...
        externals: {
           leaflet: "L",
           jquery: "$",
           "leaflet-search": [ "L", "Control", "Search" ]
        }
     }

  En este caso, las claves representan las librerías *externalizadas* (o sea, los
  valores del objeto que se pasó como argumento a Provide_) y los valores son la
  variable global asociada a aquello que exporte la librería. Por tanto, muy
  comúnmente al usar Provide_ y externals lo que se hace es intercambiar claves
  por valores y valores con claves, con la diferencia que en *externals* un
  identificador que no sea global, sino el atributo de otro objeto debe notarse en
  forma de *array*. Es por ello que :code:`L.Control.Search` se ha convertido en
  :code:`["L", "Control", "Search"]`.

  No obstante, si la librería externa se construyó como :ref:`módulo UMD
  <mod-umd>`, entonces es necesario definir cómo está disponible la librería
  dependiendo del sistema que se use para cargarla:

  .. code-block:: js

     externals: {
        leaflet: {
           root: "L",
           commonjs: "leaflet",
           commonjs2: "leaflet",
           amd: "leaflet"
        }
     }

  .. warning:: Si creamos una librería de terceros que queremos, no sólo que pueda
     cargarse desde un navegador, sino que pueda usarse como componente en un
     desarrollo posterior con NodeJS_, deberemos usar esta ultima forma para definir
     sus dependencias.

  .. warning:: Si al usar el *plugin* Provide_ se usó con algún identificador un
     array:

     .. code-block:: js

        plugins: [
           new webpack.ProvidePlugin({
              L: "leaflet",
              "L.MarkerClusterGroup": ["leaflet.markerclustergroup", "MarkerClusterGroup"]
           })
        ]
        
     entonces la propiedad exportada (*MarkerClusterGroup* en este ejemplo),
     será añadida automáticamente a la variable global que se indique en
     *externals*. Por ese motivo, *externals* debe definirse así:

     .. code-block:: js

        externals: {
           leaflet: "L",
           "leaflet.markerclustergroup": "L"
        }

     y no asociando :code:`["L", "MarkerCLusterGroup"]` a
     *leaflet.markerclustergroup*.

* Para el **resto** de ficheros, la forma de exclusión depende de cómo se
  importara:

  - Si se hizo a través del punto de entrada en la configuración, la solución
    es que no aparezca en el punto de entrada, así que en caso de tener salidas
    que incluyen dependencias y salidas sin ellas, habría que hacer una
    configuración condicional en que el valor del punto de entrada dependiera de
    cuál es el sabor de la salida que se genera.

  - Si la importación se incluyó en el código, la forma de evitar que los
    ficheros pasen a la salida es usar el cargador `ignore-loader`_, que como
    elocuentemente indica su nombre, no hace absolutamente nada con el fichero
    que trata.

    .. note:: Tenga presente que si no tenemos ficheros propios (|CSS|, por
       ejemplo) es bastante sencillo hacer una configuración condicional para
       que en el sabor *bundle* se traten los ficheros con el cargador adecuado
       y en los sabores sin dependencias con :program:`ignore-loader`. Sin
       embargo, si nuestra librería incorpora ficheros propios entonces en los
       sabores sin dependencias habrá que distintguir si el fichero procede de
       :file:`node_modules`, en cuyo caso habrá que ignorarlos, o de nuestro
       código, en cuyo caso habrá que tratarlo.

.. seealso:: En el :ref:`ejemplo de desarrollo de un plugin <webpack-ej-plugin>`
   ponemos en prácticas todas estas técnicas, incluida la nota justamente
   anterior.

.. _webpack-output:

Salida
======
Hasta el momento, la definición de nuestra salida se ha reducido a:

.. code-block:: js

   output: {
      filename: "js/[name].bundle.js"
   }   

o sea, a definir el nombre que tendrá cada :ref:`punto de entrada
<webpack-entry-point>`. Además, por defecto, el directorio predeterminado de
salida es :file:`dist`, de modo que, si un punto de entrada se llama
*leaflet.mipluginmolon*, la salida se almacenará en
:file:`dist/js/leaflet.mipluginmolon.bundle.js`.

Ruta
----
Un primer cambio consiste en alterar el fichero predeterminado:

.. code-block:: js
   :emphasize-lines: 1, 2, 7

   const config = {
      entry: "./src/js/index.js",
      output: {
         path: path.resolve(__dirname, "docs"),
         filename: "js/[name].bundle.js"
      }
   }

   module.exports = config

.. _webpack-output-formato:

Formato
-------
Un segundo aspecto muy importante es el formato de salida del módulo, porque es
indispensable que el código sea accesible, si se ejecuta en un navegador.
Podemos distinguir tres casos:

- Si nuestro código no exporta nada y no importa ninguna librería porque
  si usa de terceros, está incluida en el código *Javascript* resultante\ [#]_,
  no necesitamos hacer ninguna definición especial sobre el formato.

- Si nuestro código no necesita exportar nada, pero importa alguna librería
  externa a la que se acceda a través de una variable global\ [#]_, entonces
  es necesario que tenga :ref:`formato UMD <mod-umd>`:

  .. code-block:: js

     output : {
        filename: "js/[name].bundle.js",
        libraryTarget: "umd",
        umdNamedDefine: false
     }
 
  Ahora bien, si contribuye definiendo alguna función o similar, aunque no
  necesite importar porque la integre dentro de un objeto global ya preexistente
  (p.e. desarrollamos un *plugin* de Leaflet_ que añade al objeto :code:`L` la
  clase :code:`L.MiPlugin`), es conveniente que el *plugin* exporte esa
  función:

  .. code-block:: js

     // ...
     export default L.MiPlugin = MiPlugin

  y que declaremos así la salida:

  .. code-block:: js
     :emphasize-lines: 5

     output : {
        filename: "js/[name].bundle.js",
        libraryTarget: "umd",
        umdNamedDefine: false,
        libraryExport: "default"
     }
 
  que significa que el código exportará directamente lo exportado como
  *default*.

- Si nuestro código necesita exportar al ambiente global, entonces debemos hacer
  también un módulo |UMD|, pero asignando un nombre a lo exportado:

  .. code-block:: js

     output : {
        filename: "js/[name].bundle.js",
        libraryTarget: "umd",
        umdNamedDefine: true,
        library: "X"
     }

  Al hacer esto, aquello que exporte nuestro código estará disponible a través
  de la variable global *X*. Por ejemplo, si nuestro desarrollo es este:

  .. code-block:: js

     function saludo() {
         console.log("Hola, soy tu aplicación");
     }

     const version = "0.1",
           predeterminado = true;

     export {saludo, version};
     export default predeterminado;

  Al cargar el *script* resultante en un navegador:

  .. code-block:: html

     <script src="dist/codigo.js"></script>

  Dispondremos de :code:`X.version`, :code:`X.saludo()` y :code:`X.default`.
  Incluso aunque sólo se exporte una entidad y está se defina como
  predeterminada, tendremos que usar :code:`X.default`. Si se quiere que
  una de las entidades exportadas esté accesible directamente a través de
  :code:`X`, entonces puede añadirse *libraryExport*:

  .. code-block:: js

     output : {
        filename: "js/[name].bundle.js",
        libraryTarget: "umd",
        umdNamedDefine: true,
        library: "X",
        libraryExport: "default"
     }

  En este caso :code:`X` devolverá directamente :code:`true` y el resto
  de exportaciones no está disponible.

.. _webpack-process:

Procesamiento
=============
En principio, :program:`webpack` procesa de forma nativa sólo código
*Javascript* por lo que cualquier otro tipo de fichero requiere declarar
mediante qié cargador debe procesarse. Esto precisamente es lo que se nos
presentó al :ref:`configurar la aplicación simple <webpack-simple>` que tenía
ficheros |HTML| y |CSS|.

Para llevar a cabo el procesamiento de ficheros no *Javascript* se requiere
definir un conjunto de reglas para cada una de las cuales se defina al menos
sobre qué tipo de ficheros se aplica y cuál es el cargador o lista de cargadores
que usará. En el ejemplo anteriormente desarrollado se encontraban estas dos
reglas:

.. code-block:: js

   module: {
      rules: [
         {
            test: /\.css$/i,
            use: [MiniCssExtractPlugin.loader,
                  "css-loader"]
         }
      ]
   }

esto es, una para la página web, que usa el cargador *html-loader*, y otra para
el |CSS| que usa los cargadores *css-loader* y
:program:`MiniCssExtractPlugin.loader`.

En el ejemplo, hay dos aspectos interesantes a destacar:

* Los cargadores, como en el caso de la primera regla admiten opciones. En este
  caso, además de la sintaxis indica arriba, se puede usar otra más compacta:

  .. code-block:: js

      {
         test: /\.html$/,
         use: "hml-loader?minimize=true"
      }

  en la que las opciones del cargador pueden proporcionarse con una sintaxis
  parecida a la *query string* de una |URL|.

* En cada regla (como en el caso de la segunda) pueden aplicarse varios
  cargadores encadenadamente, Contrariamente a lo que podría parecer más natural
  el orden de aplicación es de derecha a izquierda.

Hay, además, otros atributos que pueden añadir `condiciones
<https://webpack.js.org/configuration/module/#condition>`_ a las reglas como
`include <https://webpack.js.org/configuration/module/#ruleinclude>`_, `exclude
<https://webpack.js.org/configuration/module/#ruleexclud>`_, o `issuer
<https://webpack.js.org/configuration/module/#ruleissuer>`_, esta última
aplicable no al nombre del recurso que se procesa, sino al nombre del fichero en
el que se encontra la invocación al recurso. También es interesante `oneOf
<https://webpack.js.org/configuration/module/#ruleoneof>`_ para proporcionar una
lista de reglas, de las que sólo se procesará la primera que se ajuste a las
condiciones indicadas.

.. seealso:: Esta `respuesta en stackoverflow.com
   <https://stackoverflow.com/a/46769010>`_ es bastante elocuente para entender
   cómo se aplican las condiciones.

Es también interesante reseñar que *use* puede ser una función que devuelva el
array de cargadores, lo que permite generar tal lista dinámicamente:

.. code-block:: js

   {
      test: /\.css$/i,
      use: function(rsc) {
         console.log("Procesando... ", src.resource);
         return ["style-loader", "css-loader"];
      }
   }

Ficheros en general
-------------------
Si retomamos el :ref:`HTML de la aplicación simple <webpack-simple-html>` y añadimos
alguna imagen:

.. code-block:: html

   <!DOCTYPE html>
   <html lang="es">
   <head>
      <meta charset="UTF-8">
      <title>Aplicación simple</title>
   </head>
   <body>
      <h1>Aplicación simple</h1>
      <img src="images/logo512.png" alt="Logo HTML grande">
      <img src="images/logo64.png" alt="Logo HTML pequeño">
   </body>
   </html>

.. note:: Para las imágenes se han tomando el logo de |HTML|\ 5, descargado de
   la `página oficial <https://www.w3.org/html/logo/>`_, en tamaño de 512px y
   64px.

Si probáramos inmediatamente a regenerar el *bundle*, veríamos que escupe un
error como consecuencia de que no sabe manejar este tipo de ficheros. Para
evitarlo es preciso usar :program:`file-loader`:

.. code-block:: console

   $ npm install file-loader

un cargador que es capaz de tomar cualquier fichero y copiarlo en la salida que
indiquemos:

.. code-block:: js

   {
      test: /\.(png|jpe?g|gif|svg)$/i,
      use: ['file-loader?name=images/[name].[ext]']
   }
   
.. note:: En el ejemplo, se utiliza únicamente para imágenes, pero puede ser
   cualquier tipo de fichero, incluido |CSS|. Sin embargo, no es recomendable
   utilizarlo para hojas de estilo en algunos casos. Profundizaremos en el
   :ref:`procesamiento de CSS más adelante <webpack-css>`.

Una alternativa a :program:`file-loader` es :program:`url-loader` (que
internamente necesita :program:`file-loader`)

.. code-block:: console

   $ npm install file-loader url-loader

y que se encarga de dos cosas:

- Copiar el fichero al resultado final.
- Si el fichero es menor que el límite definido (en el ejemplo 4K), en vez
  de copiar el fichero genera una dataURI_ en Base64.

Su uso es idéntico al de :program:`file-loader` excepto porque debemos indicar
cuál es el límite:

.. code-block:: js

   {
      test: /\.(png|jpe?g|gif|svg)$/i,
      use: ['url-loader?limit=4096&name=images/[name].[ext]']
   }

Para imágenes exclusivamente puede incorporarse, además, :program:`img-loader`
que funciona como minimizador:

.. code-block:: console

      # npm install --save-dev img-loader

con una configuración:

.. code-block:: js

   {
      test: /\.(png|jpe?g|gif|svg)$/i,
      use: [
         'url-loader?limit=4096&name=images/[name].[ext]',
         'img-loader'
      ]
   }

.. note:: Obsérvese que :program:`file-loader` copia ficheros sin alterarlos,
   pero no mantiene la estructura de directorios. En todos los ejemplos que
   hemos expuesto, las imágenes estén donde estén, acaban en un subdirectorio
   llamado :file:`images`. Para copiar una estructura completa es necesario
   recurrir al plugin CopyPlugin_.

.. _webpack-css:

|CSS|
-----
El procesamiento de ficheros |CSS| admite variantes dependiendo de cuál queremos
que sea el resultado del procesamiento. Sin demasiadas explicaciones utilizamos
esta:

.. code-block:: js

   {
      test: /\.css$/i,
      use: [MiniCssExtractPlugin.loader, "css-loader"]
   }

:program:`css-loader` procesa el |CSS| que se enlaza con la clausula
:code:`import` o se incluye como punto de entrada y genera un módulo de
*Javascript*. Como esta salida es aún inútil, se presentan varias alternativas:

:program:`MiniCssExtractPlugin.loader`
   Toma todos los módulos y los compone en un único fichero |CSS| que se coloca
   en el directorio de salida definico mediante *output* y con el nombre que
   se proporcione al plugin al incorporarlo a la sección *plugins*.

:program:`style-loader`
   Toma los módulos y los incluye dentro de un elemento style_ del |HTML|:

   .. code-block:: js

      {
         test: /\.css$/i,
         use: ["style-loader", "css-loader"]
      }

:program:`file-loader`\ +\ :program:`extract-loader`
   :program:`extract-loader` permite tomar los módulos y generar cadenas de
   texto, mientras que :program:`file-loader` es capaz de tomar esas cadenas de
   texto y generar ficheros de salida, uno por cadena (o sea, por fichero de
   entrada) con lo que se obtendrán multiples ficheros en vez de uno solamente
   como al usar :program:`MiniCssExtractPlugin.loader`:

   .. code-block:: js

      {
         test: /\.css$/i,
         use: ["file-loader?name=[path][name].css",
               "extract-loader",
               "css-loader"]
      }

   .. note:: Obsérvese que, aunque se obtiene un fichero de salida por cada
      fichero de entrada, que es lo que obtendría usando únicamente
      *file-loader*, hay una gran diferencia en esta configuración:
      :program:`css-loader` entiende y analiza los ficheros |CSS| por lo que es
      capaz de reconocer enlaces a otros ficheros incluidos en su contenido a
      través de cláusulas :code:`@import` o :code:`url()`. El efecto es que esos
      ficheros referidos también pasarán a procesarse sin necesidad de
      referirlos explícitamente como punto de entrada o importarlos en el código
      *Javascript* con :code:`import`.

Por otro lado, también se puede añadir cargadores que actúan **antes** de la
intervención de :program:`css-loader`:

:program:`postcss-loader`
   Opera sobre el |CSS| realizando transformaciones que nos resulten
   pertinentes:

   .. code-block:: console

      $ npm install --save-dev postcss-loader autoprefixer cssnano
  
   Hay al menos dos que nos pueden resultar intersantes:

   - La que realiza el plugin :program:`autoprefixer`, que añade prefijos del
     vendedor a las opciones cuando es preciso. Obviamente, debe operar
     justamente antes de :program:`css-loader`. La configuración, suponiendo que
     queramos obtener un único |CSS|, quedará del siguiente modo:

     .. code-block:: js
        :emphasize-lines: 5-10

        {
           test: /\.css$/i,
           use: [MiniCssExtractPlugin.loader,
                 "css-loader",
                 { 
                    loader: "postcss-loader",
                    options: {
                       plugins: () => [require("autoprefixer")]
                    }
                 }]
        }

     .. note:: Para saber para qué navegadores debe añadir prefijos, este *plugin*
        usa la :ref:`librería browserlist <browserlist>`, que introduciremos al
        tratar :ref:`babel <babel>`.

     .. note:: Para comprobar que este cargador realmente actúa, podemos
        añadir al |CSS| de algún ejemplo, las líneas:

        .. code-block:: js

           ::placeholder {
              color: gray;
           }

   - La que realiza el plugin :program:`cssnano`, que minimiza el
     |CSS|:

     .. code-block:: js
        :emphasize-lines: 5-12

        {
           test: /\.css$/i,
           use: [MiniCssExtractPlugin.loader,
                 "css-loader",
                 { 
                    loader: "postcss-loader",
                    options: {
                       plugins: [
                          require("cssnano")({preset: "default"})
                       ]
                    }
                 }]
        }

:program:`sass-loader` o :program:`less-loader` u otra cargador semejante.
   Cuando no escribimos el estilo en |CSS| sino en otro lenguaje como |SASS| o
   Less_, requerimos de otro cargador previo que sea capaz de cargar el traductor
   que realice la tranformación a |CSS|. Por ejemplo:

   .. code-block:: console

      $ npm install --save-dev sass-loader node-sass
      $ npm install --save-dev less-loader node-less

   Si optamos por |SASS|, la configuración podría ser esta:

   .. code-block:: js

      {
         test: /\.(css|sass)$/i,
         use: [MiniCssExtractPlugin.loader,
               "css-loader", 
               // Aquí en medio podríamos postcss-loader
               "sass-loader"]
      }

   Como el procesador de |SASS| no lleva a cabo ninguna transformación si se
   topa con un fichero |CSS|, la regla anterior es perfectamente válida también
   para ficheros |CSS|.

   Con esta regla, podríamos escribir el estilo:

   .. code-block:: sass

      /* Fichero sass/main.sass */
      $fondo: yellow

      body
         background-color: $fondo

Procesamiento automático
------------------------
Por procesar ficheros automáticamente entendemos hacer que participen en el
procesamiento y pasen a formar parte del resultado sin incluirlos explícitamente
como punto de entrada. Se procesan automáticamente:

- Si se usa el plugin HtmlWebPackPlugin_, las imágenes referidas en los
  atributos *src* de las etiquetas img_.
- Si se usa :program:`css-loader` para procesar el código |CSS|, las imágenes
  incluidas en sentencias :code:`url()` y las hojas importadas a través de
  :code:`import`.

En cambio, si referimos directamente un fichero dentro del código *Javascript*
como en el ejemplo:

.. code-block:: js

   const img = document.createElement("img");
   img.setAttribute("alt", "Logo introducido al vuelo");
   img.setAttribute("src", "images/logo.svg");
   document.body.appendChild(img);

:file:`images/logo.svg` no se detectará como recurso y, en consecuencia, la
imagen no se procesará automáticamente. Para forzar este procesamiento, lo que
se debe hacer es importar el fichero a una variable y usar esta variable como
recurso:

.. code-block:: js

   import logo from "./logo.svg";

   const img = document.createElement("img");
   img.setAttribute("alt", "Logo introducido al vuelo");
   img.setAttribute("src", logo);
   document.body.appendChild(img);

.. _babel:

Compatibilidad
==============
:program:`Babel` es un componente fundamental de nuestro propósito puesto que
permite sustituir sintaxis demasiado nueva por otra compatible con versiones más
antiguas de *Javascript*. Para usarlo y que transpile\ [#]_ de forma que quede una
sintaxis ampliamente soportada, podemos añadir algunas líneas a
:file:`webpack/webpack.production.js`:

.. literalinclude:: files/webpack.production.babel.js
   :language: js

e instalar los paquetes pertinentes:

.. code-block:: console

   $ npm install --save-dev babel-loader @babel/core @babel/cli @babel/preset-env

.. _browserlist:

Este es el uso más simple, pero podemos ser bastante precisos y afinar mucho más
cuáles son los navegadores que pretendemos soportar. Para ello, debemos tener
presente que :program:`babel` es capaz de usar `la librería browserslist
<https://github.com/browserslist/browserslist>`_, en cuya documentación puede
leerse cómo expresar el grado de compatibilidad que se pretende conferir al
código. Hay varios modos de incluir este grado de compatibilidad, pero la
documentación recomienda el de incluirlo en :file:`package.json` a través de
la propiedad *browserslist*:

.. code-block:: js

   "browserslist": {
     "production": [
        "cover 95% in ES"
     ],
     "oneplus": [
        "> 1% in ES"
     ],
     "ie10": [
        "> .25% in ES",
        "ie >= 10"
     ],
     "relaxed": [
        "cover 80% in ES"
     ]
   }

Para probar la lista de navegadores que soportará el código podemos usar la
orden::

   $ npx browserslist

que usa la definición dada por *production*, pero podemos aplicar cualquier otra,
dando un valor a la variable de ambiente *NODE_ENV*::

   $ NODE_ENV=relaxed npx browserslist

Por tanto, podemos componer nuestra aplicación con::

   $ npm run build
   $ NODE_ENV=relaxed npm run build

.. rubric:: Polyfill

Si se requiere dar soporte en navegadores antiguos a funciones como Promise_,
Object.assign_ o `Array.from`_ es precisa una configuración más que depende de
si disponemos de una versión de :program:`babel` anterior a la **7.4**.

Para versiones anteriores se debe:

#. Instalar el paquete *@babel/polyfill*::

      # npm install --save @babel/pollyfill

   .. note:: No hay errata. Se debe instalar como dependencia y no como
      dependencia de desarrollo.

#. Modificar la configuración de :program:`webpack` para añadir una opción a
   :program:`babel`:

   .. literalinclude:: files/webpack.production.babel.polyfill.js
      :language: js
      :emphasize-lines: 17

   Con esa opción, sólo se añadirán al código *Javascript* resultante, el
   codigo necesario para implementar las funciones pertienen que hayamos
   incorporado al código.

A partir de la versión *7.4.0*, `la documentación recomienda usar core-js
<https://babeljs.io/docs/en/babel-polyfill>`_ para lo cual:

#. Instalamos el paquete correspondiente::

      # npm install --save core-js@3

#. Modificamos la configuración de :program:`webpack` para añadir un par de
   opciones a :program:`babel`:

   .. literalinclude:: files/webpack.production.babel.polyfill2.js
      :language: js
      :emphasize-lines: 17, 18

.. note:: Para probar la configuración, podemos añadir alguna sentencia sencilla
   al nuestro código *Javscript* que requiera *polyfill* como, por ejemplo:

   .. code-block:: js

      Object.assign({}, {a:1});

   Si probamos a generar le código con y sin la sentencia anterior y comparamos
   cuánto pesan ambos ficheros veremos una ostensible diferencia, ya que con la
   sentencia propuesta se tendrá que añadir el código necesario para implementar
   la función. Como sólo se añade el código indispensable para implementar las
   funciones necesarias, es buena idea configurar siempre *polyfill*.

.. _webpack-debug:

Depuración
==========
Para un desarrollo ágil de la aplicación es fundamental que configuremos
adecuadamente :program:`webpack-dev-server`, a fin de que podamos comprobar
sobre la marcha los cambios que aplicamos al código. Esta configuración se hace
a través del atributo *devServer*:

.. code-block:: js

   devServer: {
      open: "chromium"
   }

En principio, sirve a través del servidor web (en la dirección
:file:`http:/localhost:8080`) los ficheros resultantes del procesamiento, los
cuales **no** llegan a escribirse en disco.  Además, fusiona con ellos el
directorio raíz del proyecto. En consecuencia, si nuestro proyecto tiene unos
ficheros originales :file:`src/index.html` y :file:`src/index.js` que se
transforman en :file:`dist/index.html` y :file:`dist/index.bundle.js` resultará
que:

============================  =============================================
Fichero                       Accesible mediante
============================  =============================================
:file:`src/index.html`        :file:`http://localhost:8080/src/index.html`
:file:`src/index.js`          :file:`http://localhost:8080/src/index.js`
:file:`dist/index.html`       :file:`http://localhost:8080/index.html`
:file:`dist/index.bundle.js`  :file:`http://localhost:8080/index.bundle.js`
============================  =============================================

.. warning:: Obsérvese que la ruta relativa entre los ficheros generados
   y los fichero no generados cambia en el servidor web. Esto no quiere
   decir que el directorio :file:`dist/` desaparezca. Si existía previamente
   y contenía ficheros de anteriores procesamientos estos continuarán siendo
   accesibles dentro de :file:`http://localhost:8080/dist`. Son los ficheros
   generados, que no se llegan a escribir físicamente en disco, los que aparecen
   en la raíz del servidor.

Este comportamiento, sin embargo. puede alterarse con algunas opciones:

* *contentBase* indica un directorio del sistema de ficheros que se
  quiere fusionar con la directorio raíz del servidor wen. Su valor
  predeterminado es el directorio raíz del proyecto, de ahí que resulte lo que
  acabamos de explicar.  Podemos, no obstante, definir otro cualquiera (usando
  una ruta relativa, eso sí). Por ejemplo:

  .. code-block:: js

     devServer: {
        contentBase: path.resolve(__dirname, "examples"),
        //watchContentBase: true,
        open: "chromium"
     }

   en cuyo caso, se fusionará el subdirectorio :file:`examples`. Si, además,
   añadimos *watchContentBase* el servidor no sólo vigilará cambios en los
   ficheros generados, sino también cambios en los ficheros estáticos contenidos
   en :file:`examples`.

   Si el valor de *contentBase* es ``false``, sólo estarán disponibles los
   ficheros generados.

* *publicPath* permite cambiar la ruta en el servidor donde aparecerán los
  ficheros generados. En consecuencia, esta configuración:

  .. code-block:: js

     devServer: {
        publicPath: "/dist/",
        open: "chromium"
     }

  provocará este efecto:

  ============================ ===================================================
  Fichero                       Accesible mediante
  ============================ ===================================================
  :file:`src/index.html`        :file:`http://localhost:8080/src/index.html`
  :file:`src/index.js`          :file:`http://localhost:8080/src/index.js`
  :file:`dist/index.html`       :file:`http://localhost:8080/dist/index.html`
  :file:`dist/index.bundle.js`  :file:`http://localhost:8080/dist/index.bundle.js`
  ============================ ===================================================

  Como puede verse, los ficheros estáticos del sistema de ficheros siguen
  compartiéndose en la raíz del servidor web.

Por su parte, la otra opción, *open*, rige qué se hace al levantar el
servidor:

- Si es ``false``, que es su valor predeterminado al no haber incluido el
  argumento :code:`--open`\ [#]_ en :file:`package.json`, no se abre una ventana
  con la aplicación en el navegador, así que tendremos que abrir manualmente
  nosotros la página eni la dirección::

   http://localhost:8080

- Si toma valor, debe ser una cadena que indique el navegador con el que se
  quiere ver la aplicación.

- Si es ``true``, se usa el navegador predefinido por el sistema\ [#]_.

.. note:: Aunque tenga un interés muy relativo, también es posible hacer
   que los ficheros resultantes se escriban en disco.

   .. code-block:: js

      devServer: {
         writeToDisk: true,
         contentBase: false
         open: "chromium"
      }

   En este caso, además de publicarse el contenido a través del servidor, se
   escribirán los ficheros resultantes en el directorio de salida.

Optimización
=============
Es sumamente importante mantener los ficheros resultantes dentro de un tamaño
razonable. En muchas ocasiones, el resultado contiene código inútil porque se
cargó, pero no se usa en absoluto. El apartado indica cómo localizar cuáles son
los módulos que más contribuyen al tamaño de nuestro código y cómo eliminar
código inútil.

Auscultador
-----------
Un primer paso para conocer por qué nuestro desarrolla ocupa el espacio que
ocupa, es determinar cuánto contribuye a él cada uno de sus componentes. Para
tal tarea, una herramienta muy práctica es `webpack-bundle-analyzer
<https://www.npmjs.com/package/webpack-bundle-analyzer>`_ que nos mostrará
gráficamente esta contribución:

.. image:: files/analyzer.png

Para hacer uso de ella debemos instalar la utilidad:

.. code-block:: console

   npm install --save-dev webpack-bundle-analyzer

y en la configuración para producción añadir temporalmente:

.. code-block:: js

   const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;

   // ...

   module.exports = {
      // ...
      plugins: [
         new BundleAnalyzerPlugin(),
         // ...
      ]
   }

Al llevar a cabo la generación de los ficheros, se levantará en
:file:`http://localhost:8888` la aplicación de la que se puso antes captura y
podremos comprobar cuál es el espacio al que contribuye cada componente.

Carga parcial
-------------
Para reducir el tamaño, lo más eficaz es eliminar el código que no se utilice.
Por ejemplo, si en nuestro desarrollo necesitamos análisis geoespacial,
podríamos estar tentados a hacer:

.. code-block:: js

   plugins: [
      new webpack.ProvidePlugin({
         turf: "@turf/turf"
      });
   ]

o el equivalente con :code:`import` dentro del código. Sin embargo, TurfJS_ es
una librería mastodóntica y es probable que nosotros sólo pretendamos hacer uso
de algunas de sus funciones. Por ejemplo, :code:`turf.difference` y
:code:`turf.union`. En ese caso, tenemos dos opciones:

#. Crear nuestro propio módulo, que cargue sólo estas dos funciones:

   .. code-block:: js

      // ./src/turf.js
      import difference from "@turf/difference";
      import union from "@turf/union";

      export {difference, booleanPointInPolygon};

   y asociarlo al identificador *turf*:
   
   .. code-block:: js

      plugins: [
         new webpack.ProvidePlugin({
            turf: "./src/turf.js"
         });
      ]

   Y si queremos *externalizar* el uso de la librería:

   .. code-block:: js

      externals: {
         "./scr/turf.js": "turf"
      }

#. Definir los dos identificadores por separado:

   .. code-block:: js

      plugins: [
         new webpack.ProvidePlugin({
            "turf.difference": "@turf/difference",
            "turf.union": "@turf/union",
         });
      ]

   lo cual exigirá la siguiente *externalización*:

   .. code-block:: js

      externals: {
          "@turf/difference": ["turf", "difference"],
          "@turf/union": ["turf", "union"]
      }

.. _webpack-multi:

Múltiples resultados
====================
Lo habitual es que para un desarrollo nos interese generar varias salidas
distintas tales como:

#. :file:`script.js`: De **producción**, transpilada, minimizada y sin
   dependencias. La generaremos con:

   .. code-block:: console

      npm run build

#. :file:`script.bundle.js`: De **producción**, transpilada, minimizada y con
   todas las dependencias. La generaremos con:

   .. code-block:: console

      npm run build:bundle

#. :file:`script-src.js`: De **producción**, transpilada, no minimazada y
   sin dependencias. La generaremos con:

   .. code-block:: console

      npm run build:src

#. :file:`script-debug.js`: De **desarrollo**, no transpilada ni minimizada y
   sin dependencias. Además, debería incluir mapeos del código. La generaremos
   con:

   .. code-block:: console

      npm run build:debug

#. :file:`script.js`: De **desarrollo** como la anterior para deparar
   interactivamente con :program:`webpack-dev-server`. La generaremos con

   .. code-block:: console

      npm run debug

Para esto, deberemos dejar unos *scripts* en :file:`package.json` así:

.. code-block:: js

   "scripts": {
       "build": "webpack --env.output=min",
       "build:bundle": "webpack --env.output=bundle",
       "build:src": "webpack --env.output=src",
       "build:debug": "webpack --env.output=srcdebug",
       "debug": "webpack-dev-server --env.output=debug"
   }

donde la forma de distinguir una salida de otra es mediante un objeto *env* que
nos encargaremos de desarrollar más adelante. No obstante, dependiendo de cuál
sea el objetivo de nuestro desarrollo podremos prescindir de algunas salidas:

- Para una aplicación final, suele bastar con las salidas (2) y (5).
- Si desarrollamos una librería intermedia pueden llegar a interesarnos hasta
  las cinco salidas:

  #. Para usarse directamente con el navegador.
  #. Paa el mismo uso anterior, pero evitando que se deban cargar las
     dependencias.
  #. Para incorporarla a otros proyectos desarrollados con NodeJS_.
  #. Para brindar la posibilidad a un tercero de analizar el código sin instalar
     el paquete y usar NodeJS_ y :program:`webpack`.
  #. Para depurar cómodamente mientras desarrollamos la aplicación.

Los ejemplos que trataremos, desarrollarán dos casos de ejemplo: uno desarrolla
una aplicación final, y el otro un sencillo *plugin* para Leaflet_, o sea, una
libería intermedia.

Comprobación
============
Es bastante interesante comprobar si la configuración que hemos llevado a cabo
genera el objeto de configuración que presuponemos. Para ello, y suponiendo que
hayamos usando el objeto *env*, podemos usar la consola de NodeJS_:

.. code-block:: console

   > x = require("./webpack.config.js");
   > x({output: "min"});  // Y el resto de salidas.

Se imprimirá el objeto de configuración resultante y podremos comprobar si es el
que esparábamos.

.. rubric:: Notas al pie

.. [#] Entiéndase que los dos scripts no tienen por qué corresponderse con dos
   ficheros. Cada uno de ellos puede estar programado de forma modular y
   componerse de múltiples ficheros.

.. [#] A menos claro está que hayamos hecho una copia incluida en nuestro
   desarrollo de ese módulo ajeno, porque el problema de las librerías de
   terceros es que se encuentran alojadas fuera del directorio de trabajo (en
   :file:`node_modules` o en el directorio global de instalación) y esa
   localización no es alcanzable por un cliente web. Otra solución es usar el
   plugin Provide_, que se explica a continuación.

.. [#] El uso de Provide_ para cargar librerías de terceros puede tener también
   otro efecto, si se ha usado la sintaxis *ES2015* y se importan sólo ficheros
   *Javascript* (otros tipos pueden añadirse al desarrollo incluyéndolos en el
   punto de entrada): usando un atributo :code:`type="module"` en un navegador
   moderno, el código fuente será directamente utilizable.

.. [#] Y aquí rige para las rutas :ref:`la misma regla que para las
   importaciones dentro del código <webpack-import-path>`. Por tanto, *leaflet*
   a secas implica que estamos cargando una librería instalada local o
   globalmente y que, en realidad, se importa el fichero que se indique como
   principal en :file:`package.json`.

.. [#] Hasta el momento, sólo sabemos crear código *Javascript* que incluye
   en el propio código todas las dependencias, pero ya veremos que hay forma
   de no hacerlo.

.. [#] Sería el caso, por ejemplo, de que crearamos un desarrollo que usa
   JQuery_ pero configurarámos :program:`webpack` para que esa librería externa
   no se incluyera dentro del código resultante, lo cual :ref:`veremos más
   adeltante que es posible <webpack-ej-plugin>`.`

.. [#] También podemos usar :program:`postcss-loader`, entre :program:`css-loader`
   y :program:`sass-loader`, pero importa poco a efectos de esta discusión.

.. [#] *Transpilar* (y transpilación y transpilador) es un término
   construido por analogía con el verbo *compilar*. De un modo análogo al que 
   :dfn:`compilar` sea convertir código de programación en código máquina,
   :dfn:`transpilar` es traducir còdigo de programación a una versión distinta,
   por ejemplo, a una más antigua para mantener la compatibilidad con versiones
   más antiguas del intérprete. Traducir de `CoffeeScript`_ o `TypeScript`_ a
   *Javascript* también es *transpilar*.

.. [#] En los sistemas *linux*, el navegador predefinido es el que se obtiene
   así:

   .. code-block:: console

      $ xdg-settings get default-web-browser
      firefox-esr.desktop

.. [#] Las variables de entorno que se pasan de forma estándar (véase *NODE_ENV*
   cuando se trataba :ref:`babel <babel>`) se encuentran disponibles en el
   script a través de :code:`process.env`:

   .. code-block:: js

      console.log(process.env.HOME)

.. _script: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script
.. _img: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img
.. _CoffeeScript: https://coffeescript.org/#introduction
.. _TypeScript: https://www.typescriptlang.org/
.. _Object.assign: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
.. _Promise: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise
.. _Array.from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from
.. _dataURI: https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs
.. _CommonJS: https://nodejs.org/docs/latest/api/modules.html
.. _Provide: https://webpack.js.org/plugins/provide-plugin/
.. _NodeJS: https://nodejs.org/
.. _CopyPlugin: https://github.com/webpack-contrib/copy-webpack-plugin
.. _style: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style
.. _Less: http://lesscss.org/
.. _JQuery: https://jquery.com/
.. _TurfJS: https://turfjs.org/
.. _Leaflet: https://leafletjs.com
.. _HtmlWebPackPlugin: https://github.com/jantimon/html-webpack-plugin
.. _ignore-loader: https://github.com/cherrry/ignore-loader

.. |HTML| replace:: :abbr:`HTML (HyperText Markup Language)`
.. |CSS| replace:: :abbr:`CSS (Cascading Style Sheets)`
.. |SASS| replace:: :abbr:`SASS (Syntactically Awesome Style Sheets)`
.. |URL| replace:: :abbr:`URL (Uniform Resource Locator)`
.. |UMD| replace:: :abbr:`UMD (Universal Module Definition)`
